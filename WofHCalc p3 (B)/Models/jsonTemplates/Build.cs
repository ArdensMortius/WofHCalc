// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using WofHCalc.Models.jsonTemplates;
//
//    var build = Build.FromJson(jsonString);

namespace WofHCalc.Models.jsonTemplates
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;
    using WofHCalc.Supports;

    public partial class Build
    {
        [J("buildtime")] public double[] Buildtime { get; set; }
        [J("cost")] public Cost[] Cost { get; set; }
        [J("effect")] public double[] Effect { get; set; }
        [J("efficiency")] public double Efficiency { get; set; }
        [J("group")] public int Group { get; set; }
        [J("maxcount")] public int Maxcount { get; set; }
        [J("next")] public BuildName[] Next { get; set; }
        [J("pay")] public double[] Pay { get; set; }
        [J("race")] public Race Race { get; set; }
        [J("slot")] public Slot Slot { get; set; }
        [J("terrain")] public Terrain Terrain { get; set; }
        [J("type")] public BuildType Type { get; set; }
        [J("ungrown")] public double[] Ungrown { get; set; }
        [J("unitstrain", NullValueHandling = N.Ignore)] public long[] Unitstrain { get; set; }
        [J("productres", NullValueHandling = N.Ignore)] public Productre[] Productres { get; set; }
        //[J("wonderradius", NullValueHandling = N.Ignore)] public long? Wonderradius { get; set; }
    }

    public partial class Productre
    {
        [J("res")] public ResName Res { get; set; }
    }

    public partial struct Cost
    {
        public double? Double;
        public double[] DoubleArray;

        public static implicit operator Cost(double Double) => new Cost { Double = Double };
        public static implicit operator Cost(double[] DoubleArray) => new Cost { DoubleArray = DoubleArray };
    }

    public partial class Build
    {
        public static Build[] FromJson(string json) => JsonConvert.DeserializeObject<Build[]>(json, WofHCalc.Models.jsonTemplates.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Build[] self) => JsonConvert.SerializeObject(self, WofHCalc.Models.jsonTemplates.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                CostConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CostConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Cost) || t == typeof(Cost?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Cost { Double = doubleValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<double[]>(reader);
                    return new Cost { DoubleArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Cost");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Cost)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.DoubleArray != null)
            {
                serializer.Serialize(writer, value.DoubleArray);
                return;
            }
            throw new Exception("Cannot marshal type Cost");
        }

        public static readonly CostConverter Singleton = new CostConverter();
    }
}
